<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" href="style.css" />
	<title>Brief Reference</title>
<style>
</style></head>
<body>

<h1>Brief Reference</h1>

<p>The following table is a brief overview of the functionality of PyGLPK.  The intention was to present functionality in roughly the same order and groupings that they do in the GLPK reference manual, at least where appropriate.  This table contains a brief description of some functionality, some simple Python code illustrating the general principles of usage, the related C API function (for the benefit of those familiar with GLPK), and a link to more detailed documentation on this subject.</p>

<table class="cpycomp" width="100%">
<thead><th>Python Module</th><th>C API</th><th>?</th></thead>

<tr class="section"><th colspan="3">Problem attributes</th></tr>

<tr class="desc"><td colspan="2">Create or delete problem object</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#lp_create">?</a></td></tr>
<tr><td class="pymod"><code>lp = glpk.LPX()</code></td>
<td class="capi"><code>lpx_create_prob</code></td></tr>

<tr><td class="pymod"><code>del lp</code> or just let garbage collector handle it</td>
<td class="capi"><code>lpx_delete_prob</code></td></tr>

<tr class="desc"><td colspan="2">Set or get problem name</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#lp_name">?</a></td></tr>
<tr><td class="pymod"><code>lp.name = "pname"</code> or <code>del lp.name</code></td>
<td class="capi"><code>lpx_set_prob_name</code></td></tr>
<tr><td class="pymod"><code>lp.name</code> (either a string or <code>None</code>)</td>
<td class="capi"><code>lpx_get_prob_name</code></td></tr>

<tr class="desc"><td colspan="2">Set or get objective function name</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#obj_name">?</a></td></tr>
<tr><td class="pymod"><code>lp.obj.name = "oname"</code> or <code>del lp.obj.name</code></td>
<td class="capi"><code>lpx_set_obj_name</code></td></tr>
<tr><td class="pymod"><code>lp.obj.name</code> (either a string or <code>None</code>)</td>
<td class="capi"><code>lpx_get_obj_name</code></td></tr>

<tr class="desc"><td colspan="2">Set or get optimization direction</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#obj_minmax">?</a></td></tr>
<tr><td class="pymod"><code>lp.obj.maximize = True</code> or <code>= False</code></td>
<td class="capi"><code>lpx_set_obj_dir</code></td></tr>
<tr><td class="pymod"><code>lp.obj.maximize</code> (either <code>True</code> or <code>False</code>)</td>
<td class="capi"><code>lpx_get_obj_dir</code></td></tr>

<tr class="desc"><td colspan="2">Add new rows or columns to a problem</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#rc_add">?</a></td></tr>
<tr><td class="pymod"><code>lp.rows.add(num_to_add)</code></td>
<td class="capi"><code>lpx_add_rows</code></td></tr>
<tr><td class="pymod"><code>lp.cols.add(num_to_add)</code></td>
<td class="capi"><code>lpx_add_cols</code></td></tr>

<tr class="desc"><td colspan="2">Set or get row or column name</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#rc_name">?</a></td></tr>
<tr><td class="pymod"><code>lp.rows[ri].name = "rname"</code> or <code>del lp.rows[rnum].name</code></td>
<td class="capi"><code>lpx_set_row_name</code></td></tr>
<tr><td class="pymod"><code>lp.cols[ci].name = "cname"</code> or <code>del lp.cols[cnum].name</code></td>
<td class="capi"><code>lpx_set_col_name</code></td></tr>
<tr><td class="pymod"><code>lp.rows[ri].name</code> (either a string or <code>None</code>)</td>
<td class="capi"><code>lpx_get_row_name</code></td></tr>
<tr><td class="pymod"><code>lp.cols[ci].name</code> (either a string or <code>None</code>)</td>
<td class="capi"><code>lpx_get_col_name</code></td></tr>

<tr class="desc"><td colspan="2">Set or get row or column bounds</td>
<td class="reflink" rowspan="4"><a href="object_doc.html#rc_bounds">?</a></td></tr>
<tr><td class="pymod"><code>lp.rows[ri].bounds = lower, upper</code> or <code>= equals</code></td>
<td class="capi"><code>lpx_set_row_bnds</code></td></tr>
<tr><td class="pymod"><code>lp.cols[ci].bounds = lower, upper</code> or <code>= equals</code></td>
<td class="capi"><code>lpx_set_col_bnds</code></td></tr>
<tr><td class="pymod" rowspan="3"><code>lp.rows[ri].bounds</code> (two values, each either a float or <code>None</code>)</td>
<td class="capi"><code>lpx_get_row_type</code></td></tr>
<tr><td class="capi"><code>lpx_get_row_lb</code></td></tr>
<tr><td class="capi"><code>lpx_get_row_ub</code></td></td></tr>
<tr><td class="pymod" rowspan="3"><code>lp.cols[ci].bounds</code> (two values, each either a float or <code>None</code>)</td>
<td class="capi"><code>lpx_get_col_type</code></td></tr>
<tr><td class="capi"><code>lpx_get_col_lb</code></td></tr>
<tr><td class="capi"><code>lpx_get_col_ub</code></td></tr>

<tr class="desc"><td colspan="2">Set or get objective coefficient or shift term</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#obj_coef">?</a></td></tr>
<tr><td class="pymod"><code>lp.obj[ci] = coef</code> (use index <code>None</code> to get shift term)</td>
<td class="capi"><code>lpx_set_obj_coef</code></td></tr>
<tr><td class="pymod"><code>lp.obj[ci]</code> (a float)</td>
<td class="capi"><code>lpx_get_obj_coef</code></td></tr>

<tr class="desc"><td colspan="2">Set or get row or column of the constraint matrix</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#rc_matrix">?</a></td></tr>
<tr><td class="pymod"><code>lp.rows[ri].matrix = [(ci1,val1), (ci2,val2), ...]</code></td>
<td class="capi"><code>lpx_set_mat_row</code></td></tr>
<tr><td class="pymod"><code>lp.cols[ci].matrix = [(ri1,val1), (ri2,val2), ...]</code></td>
<td class="capi"><code>lpx_set_mat_col</code></td></tr>
<tr><td class="pymod"><code>lp.rows[ri].matrix</code> (a list of int-col-index, float-value tuples)</td>
<td class="capi"><code>lpx_get_mat_row</code></td></tr>
<tr><td class="pymod"><code>lp.cols[ci].matrix</code> (a list of int-row-index, float-value tuples)</td>
<td class="capi"><code>lpx_get_mat_col</code></td></tr>

<tr class="desc"><td colspan="2">Set or get the whole constraint matrix</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#lp_matrix">?</a></td></tr>
<tr><td class="pymod"><code>lp.matrix = [(ri1,ci1,val1), (ri2,ci2,val2), ...]</code></td>
<td class="capi"><code>lpx_load_matrix</code></td></tr>
<tr><td class="pymod"><code>lp.matrix</code> (a list of row, column, value tuples)</td>
<td class="capi">(no analogy)</td></tr>

<tr class="desc"><td colspan="2">Delete rows or columns from problem object</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#rc_delete">?</a></td></tr>
<tr><td class="pymod"><code>del lp.rows[ri1, ri2, ...]</code> or <code>del lp.rows[r_lo:r_hi+1]<code></td>
<td class="capi"><code>lpx_del_rows</code></td></tr>
<tr><td class="pymod"><code>del lp.cols[ci1, ci2, ...]</code> or <code>del lp.cols[c_lo:c_hi+1]<code></td>
<td class="capi"><code>lpx_del_cols</code></td></tr>

<tr class="desc"><td colspan="2">Delete problem object</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#lp_create">?</a></td></tr>
<tr><td class="pymod"><code>del lp</code> or just let garbage collector handle it</td>
<td class="capi"><code>lpx_delete_prob</code></td></tr>

<tr class="section"><th colspan="3">Indexing rows and columns by name</th></tr>

<tr class="desc"><td colspan="2">Index row or column by its name</td>
<!-- <td class="reflink" rowspan="2"><a href="object_doc.html">?</a></td> --></tr>
<tr><td class="pymod"><code>lp.rows['rowname']</code>, or <code>'rowname' in lp.rows</code> to check for membership</td>
<td class="capi"><code>lpx_find_row</code></td></tr>
<tr><td class="pymod"><code>lp.cols['colname']</code>, or <code>'colname' in lp.cols</code> to check for membership</td>
<td class="capi"><code>lpx_find_col</code></td></tr>
<tr><td>The index is created when required.</td><td class="capi"><code>lpx_create_index</code></td></tr>
<tr><td></td><td class="capi"><code>lpx_delete_index</code></td></tr>

<tr class="section"><th colspan="3">Problem scaling</th></tr>

<tr class="desc"><td colspan="2">Scale or unscale problem data</td>
<td class="reflink" rowspan="4"><a href="object_doc.html#lp_scale">?</a></td></tr>
<tr><td class="pymod"><code>lp.scale()</code></td>
<td class="capi"><code>lpx_scale_prob</code></td></tr>
<tr><td class="pymod"><code>lp.scale(False)</code></td>
<td class="capi"><code>lpx_unscale_prob</code></td></tr>

<tr class="section"><th colspan="3">Basis operations</th></tr>

<tr class="desc"><td colspan="2">Construct trivial initial LP basis</td>
<td class="reflink" rowspan="8"><a href="object_doc.html#lp_basis">?</a></td></tr>
<tr><td class="pymod"><code>lp.std_basis()</code></td>
<td class="capi"><code>lpx_std_basis</code></td></tr>

<tr class="desc"><td colspan="2">Construct advanced initial LP basis</td>
<!-- <td class="reflink" rowspan="2"><a href="object_doc.html">?</a></td> --></tr>
<tr><td class="pymod"><code>lp.adv_basis()</code></td>
<td class="capi"><code>lpx_adv_basis</code></td></tr>

<tr class="desc"><td colspan="2">Construct advanced initial LP basis with Bixby's algorithm</td>
<!-- <td class="reflink" rowspan="2"><a href="object_doc.html">?</a></td> --></tr>
<tr><td class="pymod"><code>lp.cpx_basis()</code></td>
<td class="capi"><code>lpx_cpx_basis</code> <!-- Undocumented! --> </td></tr>

<tr class="desc"><td colspan="2">Read initial LP basis from a file</td>
<!-- <td class="reflink" rowspan="2"><a href="object_doc.html#lp_basis">?</a></td> --></tr>
<tr><td class="pymod"><code>lp.read_basis(filename)</td>
<td class="capi"><code>lpx_read_bas</code></td></tr>

<tr class="desc"><td colspan="2">Set row or column status</td>
<td class="reflink" rowspan="4"><a href="object_doc.html#rc_basis">?</a></td></tr>
<tr><td class="pymod"><code>lp.rows[ri].status = newstatus</code></td>
<td class="capi"><code>lpx_set_row_stat</code></td></tr>
<tr><td class="pymod"><code>lp.cols[ci].status = newstatus</code></td>
<td class="capi"><code>lpx_set_col_stat</code></td></tr>

<tr class="section"><th colspan="3">Basic simplex solvers</th></tr>

<tr class="desc"><td colspan="2">Solve problem with the simplex method</td>
<td class="reflink" rowspan="4"><a href="object_doc.html#lp_solvers">?</a></td></tr>
<tr><td class="pymod"><code>lp.simplex()</code></td>
<td class="capi"><code>lpx_simplex</code></td></tr>

<tr class="desc"><td colspan="2">Solve problem with an exact arithmetic using simplex method</td>
<!-- <td class="reflink" rowspan="2"><a href="object_doc.html">?</a></td> --></tr>
<tr><td class="pymod"><code>lp.exact()</code></td>
<td class="capi"><code>lpx_exact</code> <!-- Undocumented! --> </td></tr>

<tr class="desc"><td colspan="2">Get generic, primal, or dual status of basic solution</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#lp_status">?</a></td></tr>
<tr><td class="pymod"><code>lp.status</code> (or <code>lp.status_s</code> to force simplex status)</td>
<td class="capi"><code>lpx_get_status</code></td></tr>
<tr><td class="pymod"><code>lp.status_primal</code> (a string)</td>
<td class="capi"><code>lpx_get_prim_stat</code></td></tr>
<tr><td class="pymod"><code>lp.status_dual</code> (a string)</td>
<td class="capi"><code>lpx_get_dual_stat</code></td></tr>

<tr class="desc"><td colspan="2">Get objective value</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#obj_value">?</a></td></tr>
<tr><td class="pymod"><code>lp.obj.value</code> (or <code>lp.obj.value_s</code> to force simplex value)</td>
<td class="capi"><code>lpx_get_obj_val</code></td></tr>

<tr class="desc"><td colspan="2">Get row or column status</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#rc_basis">?</a></td></tr>
<tr><td class="pymod"><code>lp.rows[ri].status</code> (a string, one of <code>'bs'</code>, <code>'nl'</code>,<code>'nu'</code>,<code>'nf'</code>,<code>'ns'</code>)</td>
<td class="capi"><code>lpx_get_row_stat</code></td></tr>
<tr><td class="pymod"><code>lp.cols[ci].status</code> (a string, one of <code>'bs'</code>, <code>'nl'</code>,<code>'nu'</code>,<code>'nf'</code>,<code>'ns'</code>)</td>
<td class="capi"><code>lpx_get_col_stat</code></td></tr>

<tr class="desc"><td colspan="2">Get row or column primal or dual value</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#rc_value">?</a></td></tr>
<tr><td class="pymod"><code>lp.rows[ri].primal</code> (or <code>lp.rows[ri].primal_s</code> to force simplex value)</td>
<td class="capi"><code>lpx_get_row_prim</code></td></tr>
<tr><td class="pymod"><code>lp.rows[ri].dual</code> (or <code>lp.rows[ri].dual_s</code> to force simplex value)</td>
<td class="capi"><code>lpx_get_row_dual</code></td></tr>
<tr><td class="pymod"><code>lp.cols[ci].primal</code> (or <code>lp.cols[ci].primal_s</code> to force simplex value)</td>
<td class="capi"><code>lpx_get_col_prim</code></td></tr>
<tr><td class="pymod"><code>lp.cols[ci].dual</code> (or <code>lp.cols[ci].dual_s</code> to force simplex value)</td>
<td class="capi"><code>lpx_get_col_dual</code></td></tr>

<tr class="desc"><td colspan="2">Get non-basic variable causing unboundness</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#lp_ray">?</a></td></tr>
<tr><td class="pymod"><code>lp.ray</code> (a row or column, or <code>None</code> if none has been identified)</td>
<td class="capi"><code>lpx_get_ray_info</code></td></tr>

<tr class="desc"><td colspan="2">Check solution's Karush-Kuhn-Tucker conditions</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#kkt">?</a></td></tr>
<tr><td class="pymod"><code>lp.kkt()</code></td>
<td class="capi"><code>lpx_check_kkt</code></td></tr>

<tr class="section"><th colspan="3">Manual simplex tableau operations</th></tr>

<tr><td class="pymod" rowspan="7">I may be wrong, but I do not anticipate much desire for people to roll their own simplex solvers within the Python module.  It might be nice to have though in the future, for the sake of completeness.</td>
<td class="capi"><code>lpx_warm_up</code></td></tr>

<tr><td class="capi"><code>lpx_eval_tab_row</code></td>
<!-- <td class="pymod"></td></tr> -->

<tr><td class="capi"><code>lpx_eval_tab_col</code></td>
<!-- <td class="pymod"></td></tr> -->

<tr><td class="capi"><code>lpx_transform_row</code></td>
<!-- <td class="pymod"></td></tr> -->

<tr><td class="capi"><code>lpx_transform_col</code></td>
<!-- <td class="pymod"></td></tr> -->

<tr><td class="capi"><code>lpx_prim_ratio_test</code></td>
<!-- <td class="pymod"></td></tr> -->

<tr><td class="capi"><code>lpx_dual_ratio_test</code></td>
<!-- <td class="pymod"></td></tr> -->

<tr class="section"><th colspan="3">Interior-point solver</th></tr>

<tr class="desc"><td colspan="2">Solve problem with the interior-point method</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#lp_solvers">?</a></td></tr>
<tr><td class="pymod"><code>lp.interior()</code></td>
<td class="capi"><code>lpx_interior</code></td></tr>

<tr class="desc"><td colspan="2">Get status of interior-point solution</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#lp_status">?</a></td></tr>
<tr><td class="pymod"><code>lp.status</code> (or <code>lp.status_i</code> to force interior point status)</td>
<td class="capi"><code>lpx_ipt_status</code></td></tr>

<tr class="desc"><td colspan="2">Get objective value</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#obj_value">?</a></td></tr>
<tr><td class="pymod"><code>lp.obj.value</code> (or <code>lp.obj.value_i</code> to force interior point value)</td>
<td class="capi"><code>lpx_ipt_obj_val</code></td></tr>

<tr class="desc"><td colspan="2">Get row or column primal or dual value</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#rc_value">?</a></td></tr>
<tr><td class="pymod"><code>lp.rows[ri].primal</code> (or <code>lp.rows[ri].primal_i</code> to force interior point value)</td>
<td class="capi"><code>lpx_ipt_row_prim</code></td></tr>
<tr><td class="pymod"><code>lp.rows[ri].dual</code> (or <code>lp.rows[ri].dual_i</code> to force interior point value)</td>
<td class="capi"><code>lpx_ipt_row_dual</code></td></tr>
<tr><td class="pymod"><code>lp.cols[ci].primal</code> (or <code>lp.cols[ci].primal_i</code> to force interior point value)</td>
<td class="capi"><code>lpx_ipt_col_prim</code></td></tr>
<tr><td class="pymod"><code>lp.cols[ci].dual</code> (or <code>lp.cols[ci].dual_i</code> to force interior point value)</td>
<td class="capi"><code>lpx_ipt_col_dual</code></td></tr>

<tr class="section"><th colspan="3">Mixed-integer programming solvers</th></tr>

<tr class="desc"><td colspan="2">Set or get problem class</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#lp_mip">?</a></td></tr>
<tr><td class="pymod"><code>lp.kind = int</code> or <code>= float</code></td>
<td class="capi"><code>lpx_set_class</code></td></tr>
<tr><td class="pymod"><code>lp.kind</code> (either <code>int</code> or <code>float</code>)</td>
<td class="capi"><code>lpx_get_class</code></td></tr>

<tr class="desc"><td colspan="2">Set or get column kind</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#rc_mip">?</a></td></tr>
<tr><td class="pymod"><code>lp.cols[ci].kind = int</code> or <code>= float</code></td>
<td class="capi"><code>lpx_set_col_kind</code></td></tr>
<tr><td class="pymod"><code>lp.cols[ci].kind</code> (either <code>int</code> or <code>float</code>)</td>
<td class="capi"><code>lpx_get_col_kind</code></td></tr>

<tr class="desc"><td colspan="2">Get number of integer columns</td>
<td class="reflink" rowspan="4"><a href="object_doc.html#lp_nintbin">?</a></td></tr>
<tr><td class="pymod"><code>lp.nint</code> (an integer)</td>
<td class="capi"><code>lpx_get_num_int</code></td></tr>

<tr class="desc"><td colspan="2">Get number of binary columns</td>
<!-- <td class="reflink" rowspan="2"><a href="object_doc.html">?</a></td> --></tr>
<tr><td class="pymod"><code>lp.nbin</code> (an integer)</td>
<td class="capi"><code>lpx_get_num_bin</code></td></tr>

<tr class="desc"><td colspan="2">Solve MIP problem with the B&B method</td>
<td class="reflink" rowspan="4"><a href="object_doc.html#lp_solvers">?</a></td></tr>
<tr><td class="pymod"><code>lp.integer()</code></td>
<td class="capi"><code>lpx_integer</code></td></tr>

<tr class="desc"><td colspan="2">Solve MIP problem with the advanced B&B solver</td>
<!-- <td class="reflink" rowspan="2"><a href="object_doc.html">?</a></td> --></tr>
<tr><td class="pymod"><code>lp.intopt()</code></td>
<td class="capi"><code>lpx_intopt</code></td></tr>

<tr class="desc"><td colspan="2">Get status of MIP solution</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#lp_staus">?</a></td></tr>
<tr><td class="pymod"><code>lp.status</code> (or <code>lp.status_m</code> to force MIP status)</td>
<td class="capi"><code>lpx_mip_status</code></td></tr>

<tr class="desc"><td colspan="2">Get objective value</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#obj_value">?</a></td></tr>
<tr><td class="pymod"><code>lp.obj.value</code> (or <code>lp.obj.value_m</code> to force MIP value)</td>
<td class="capi"><code>lpx_mip_obj_val</code></td></tr>

<tr class="desc"><td colspan="2">Get row or column value</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#rc_value">?</a></td></tr>
<tr><td class="pymod"><code>lp.rows[ri].value</code> (or <code>lp.rows[ri].value_m</code> to force MIP value)</td>
<td class="capi"><code>lpx_mip_row_val</code></td></tr>
<tr><td class="pymod"><code>lp.cols[ci].value</code> (or <code>lp.cols[ci].value_m</code> to force MIP value)</td>
<td class="capi"><code>lpx_mip_col_val</code></td></tr>

<tr class="desc"><td colspan="2">Check solution's integer feasibility conditions</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#kkt">?</a></td></tr>
<tr><td class="pymod"><code>lp.kktint()</code></td>
<td class="capi"><code>lpx_check_int</code></td></tr>

<tr class="section"><th colspan="3">Parameters and statistics</th></tr>

<tr class="desc"><td colspan="2">Reset default parameter values</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#params_reset">?</a></td></tr>
<tr><td class="pymod"><code>lp.params.reset()</code></td>
<td class="capi"><code>lpx_reset_parms</code></td></tr>

<tr class="desc"><td colspan="2">Set or get parameters</td>
<td class="reflink" rowspan="2"><a href="object_doc.html#params_value">?</a></td></tr>
<tr><td class="pymod" rowspan="2"><code>lp.params.<i>paramname</i> = new_value</code></td>
<td class="capi"><code>lpx_set_int_parm</code></td></tr>
<tr><td class="capi"><code>lpx_set_real_parm</code></td></tr>
<tr><td class="pymod" rowspan="2"><code>lp.params.<i>paramname</i></code></td>
<td class="capi"><code>lpx_get_int_parm</code></td></tr>
<tr><td class="capi"><code>lpx_get_real_parm</code></td></tr>

<tr class="section"><th colspan="3">Problem readers</th></tr>

<tr class="desc"><td colspan="2">Read fixed MPS format file</td>
<td class="reflink" rowspan="10"><a href="object_doc.html#lp_finput">?</a></td></tr>
<tr><td class="pymod"><code>lp = glpk.LPX(mps=filename)</code></td>
<td class="capi"><code>lpx_read_mps</code></td></tr>

<tr class="desc"><td colspan="2">Read free MPS format file</td></tr>
<tr><td class="pymod"><code>lp = glpk.LPX(freemps=filename)</code></td>
<td class="capi"><code>lpx_read_freemps</code></td></tr>

<tr class="desc"><td colspan="2">Read GNU LP format file</td></tr>
<tr><td class="pymod"><code>lp = glpk.LPX(glp=filename)</code></td>
<td class="capi"><code>lpx_read_prob</code></td></tr>

<tr class="desc"><td colspan="2">Read CPLEX LP format file</td></tr>
<tr><td class="pymod"><code>lp = glpk.LPX(cpxlp=filename)</code></td>
<td class="capi"><code>lpx_read_cpxlp</code></td></tr>

<tr class="desc"><td colspan="2">Read GNU MathProg model file</td></tr>
<tr><td class="pymod"><code>lp = glpk.LPX(gmp=filename)</code> or <code>lp = glpk.LPX(gmp=(model_file, data_file, output_file))</code></td>
<td class="capi"><code>lpx_read_model</code></td></tr>

<tr class="section"><th colspan="3">Problem and data writers</th></tr>

<tr class="desc"><td colspan="2">Write problem to fixed MPS format file</td>
<td class="reflink" rowspan="20"><a href="object_doc.html#lp_foutput">?</a></td></tr>
<tr><td class="pymod"><code>lp.write(mps=filename)</code></td>
<td class="capi"><code>lpx_write_mps</code></td></tr>

<tr class="desc"><td colspan="2">Write problem to free MPS format file</td></tr>
<tr><td class="pymod"><code>lp.write(freemps=filename)</code></td>
<td class="capi"><code>lpx_write_freemps</code></td></tr>

<tr class="desc"><td colspan="2">Write problem to GNU LP format file</td></tr>
<tr><td class="pymod"><code>lp.write(glp=filename)</code></td>
<td class="capi"><code>lpx_write_prob</code></td></tr>

<tr class="desc"><td colspan="2">Write problem to CPLEX LP format file</td></tr>
<tr><td class="pymod"><code>lp.write(cpxlp=filename)</code></td>
<td class="capi"><code>lpx_write_cpxlp</code></td></tr>

<tr class="desc"><td colspan="2">Write LP basis to fixed MPS format file</td></tr>
<tr><td class="pymod"><code>lp.write(bas=filename)</code></td>
<td class="capi"><code>lpx_write_bas</code></td></tr>

<tr class="desc"><td colspan="2">Write problem to plain text file</td></tr>
<tr><td class="pymod"><code>lp.write(prob=filename)</code></td>
<td class="capi"><code>lpx_print_prob</code></td></tr>

<tr class="desc"><td colspan="2">Write basic solution to plain text file</td></tr>
<tr><td class="pymod"><code>lp.write(sol=filename)</code></td>
<td class="capi"><code>lpx_print_sol</code></td></tr>

<tr class="desc"><td colspan="2">Write bounds sensitivity information to plain text file</td></tr>
<tr><td class="pymod"><code>lp.write(sens_bnds=filename)</code></td>
<td class="capi"><code>lpx_print_sens_bnds</code></td></tr>

<tr class="desc"><td colspan="2">Write interior point solution to plain text file</td></tr>
<tr><td class="pymod"><code>lp.write(ips=filename)</code></td>
<td class="capi"><code>lpx_print_ips</code></td></tr>

<tr class="desc"><td colspan="2">Write MIP solution to plain text file</td></tr>
<tr><td class="pymod"><code>lp.write(mip=filename)</code></td>
<td class="capi"><code>lpx_print_mip</code></td></tr>

</table>

<hr/>
Thomas Finley, 2007
</body>
</html>
