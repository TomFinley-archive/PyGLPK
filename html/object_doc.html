<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" href="style.css" />
	<title>Object Documentation</title>
<style>
	
</style></head>
<body>

<h1>Object Documentation</h1>

<table width="100%">
<tr><td valign="top">
<ul>
<li><a href="#lp">Linear Program</a><ul>
	<li><a href="#lp_create">Creating and Deleting Problems</a></li>
	<li><a href="#lp_name">Naming Problems</a></li>
	<li><a href="#lp_matrix">Constraint Matrix</a></li>
	<li><a href="#lp_nnz">Non-Zero Constraint Matrix Entries</a></li>
	<li><a href="#lp_scale">Scaling</a></li>
	<li><a href="#lp_basis">Basis Definition</a></li>
	<li><a href="#lp_mip">Problem Kind, Continuous or Mixed Integer</a></li>
	<li><a href="#lp_nintbin">Integer and Binary Columns</a></li>
	<li><a href="#lp_solvers">Solving the Problem</a></li>
	<li><a href="#lp_status">Solution Status</a></li>
	<li><a href="#lp_ray">Ray</a></li>
	<li><a href="#lp_finput">File Input</a></li>
	<li><a href="#lp_foutput">File Output</a></li></ul></li>
<li><a href="#obj">Objective Function</a><ul>
	<li><a href="#obj_name">Naming Objective Function</a></li>
	<li><a href="#obj_minmax">Minimize or Maximize</a></li>
	<li><a href="#obj_coef">Objective Coefficients</a></li>
	<li><a href="#obj_value">Objective Function Value</a></li></ul></li>
</ul></td><td valign="top"><ul>
<li><a href="#rc">Rows and Columns</a><ul>
	<li><a href="#rc_add">Adding Rows and Columns</a></li>
	<li><a href="#rc_num">Number of Rows and Columns</a></li>
	<li><a href="#rc_accessing">Indexing Rows and Columns</a></li>
	<li><a href="#rc_name">Naming Rows and Columns</a></li>
	<li><a href="#rc_bounds">Bounding Rows and Columns</a></li>
	<li><a href="#rc_matrix">Matrix Entries of Rows and Columns</a></li>
	<li><a href="#rc_nnz">Number of Non-Zero Constraint Row and Column Entries</a></li>
	<li><a href="#rc_delete">Deleting Rows and Columns</a></li>
	<li><a href="#rc_special">Special Attributes of Rows and Columns</a></li>
	<li><a href="#rc_basis">Row and Column Basis Status</a></li>
	<li><a href="#rc_mip">Column Variable Kind, Continuous or Integer</a></li>
	<li><a href="#rc_value">Row and Column Variable Values</a></li></ul></li>
<li><a href="#params">Parameter Collection</a><ul>
	<li><a href="#params_value">Parameter Values</a></li>
	<li><a href="#params_reset">Resetting</a></li></ul></li>
<li><a href="#kkt">Karush-Kuhn-Tucker Conditions</a><ul>
	<li><a href="#kkt_get">Retrieving KKT Objects</a></li></ul></li>
<li><a href="#miscnotes">Miscellaneous Notes</a><ul>
	<li><a href="#miscnotes_help">Help</a></li>
	<li><a href="#miscnotes_version">Version</a></li>
	</ul></li>
</ul></td></tr></table>

<p>This document explains the function of the classes defined in PyGLPK.  In addition to descriptions, for the benefit of those familiar with the C API, it proceeds by example and analogy to the C API: there is often some C code in one color followed by some Python code in a different color which tries to do the same thing, in this spirit:</p>

<pre class="c">
printf("Hello world!");
total = 0;
for (i=0; i<10; ++i) total += i*i;
</pre>

<pre class="py">
print "Hello world!"
total = sum(i*i for i in range(10))
</pre>

<p>Hopefully, in the case of multiline examples, it should be obvious which lines correspond to each other.</p>

<p>Reading this document through is not necessarily the best way to gain an understanding of PyGLPK if you are completely new to it.  This is organized in order of object above any other consideration: advanced obscure subjects relating to LPX objects occur before simple functionality of row and column objects.  Rather, this is intended to be a reference.</p>

<a name="lp"><h2>Linear Program</h2></a>

<p>The most basic object in PyGLPK is the LPX class, just as in the GLPK C API it is the LPX structure.  As a rule, it holds data and methods that are relevant to the linear problem as a whole.  Throughout the code in this document, the token <code>lp</code> refers to an LPX object.</p>

<a name="lp_create"><h3>Creating and Deleting Problems</h3></a>

<p>One may create the Python instance of an LPX problem with a constructor.  Note that one does not need to delete the LPX object, though it may be desirable to do so.</p>

<p>If you have maintained objects which point back to the LPX object (e.g., rows, columns, objective function), the LPX cannot be deleted until these references are discarded.  The point is that <code>del lp</code> will not necessarily result in deallocation of the LPX structure.</p>

<pre class="c">
lp = lpx_create_prob();
lpx_delete_prob(lp);
</pre>

<pre class="py">
lp = glpk.LPX()
del lp
</pre>

<a name="lp_name"><h3>Naming Problems</h3></a>

<p>One gets and sets the name for a problem by querying or assigning to the <code>name</code> attribute.  As with the C API, names are limited to 255 characters.  Unset names are <code>None</code>.  One unsets a name by assigning <code>None</code> or deleting the <code>name</code>.</p>

<pre class="c">
lpx_set_prob_name(lp, "some name");
lpx_set_prob_name(lp, NULL);
char *thename = lpx_get_prob_name(lp);
</pre>

<pre class="py">
lp.name = "some name"
del lp.name <font class="comment"># Alternately, lp.name = None</font>
thename = lp.name
</pre>

<a name="lp_matrix"><h3>Constraint Matrix</h3></a>

<p>One gets and sets the entries of the entire constraint matrix by querying or assigning the attribute <code>matrix</code>.  Assignments to <code>matrix</code> will remove previous entries.</p>

<p>Retrieving <code>matrix</code> will yeild a list of three element <code>(int,int,float)</code> tuples over the non-zero entries in this matrix, each of the form <code>(ri, ci, value)</code>, indicating that row <code>ri</code> and column <code>ci</code> (counting from 0) hold value <code>value</code>.</p>

<p>For example, consider if <code>lp</code> encoded the constraint matrix:</p>
<table align="center">
<tr align="right"><td><var>p</var></td><td>=</td>
<td> <var>x</var><sub>0</sub></td><td>+</td><td> <var>x</var><sub>1</sub></td><td>+</td><td> <var>x</var><sub>2</sub></td></tr>
<tr align="right"><td><var>q</var></td><td>=</td>
<td> 10<var>x</var><sub>0</sub></td><td>+</td><td> 4<var>x</var><sub>1</sub></td><td>+</td><td> 5<var>x</var><sub>2</sub></td></tr>
<tr align="right"><td><var>r</var></td><td>=</td>
<td> 2<var>x</var><sub>0</sub></td><td></td><td></td><td>+</td><td> 6<var>x</var><sub>2</sub></td></tr>
</table>
</td></tr>
</table>

<p>Then <code class="py">print lp.matrix</code> outputs <code class="out">[(0, 0, 1.0), (0, 1, 1.0), (0, 2, 1.0), (1, 0, 10.0), (1, 1, 4.0), (1, 2, 5.0), (2, 0, 2.0), (2, 2, 6.0)]</code>.</p>

<p>For setting rather than getting, one may set all non-zero entries of the constraint matrix by assigning an iterable with similar structure to the <code>matrix</code> attribute.  The iterable must yield values each in one of these two forms:</p>

<ul>
<li>The integer-integer-float tuple <code>(ri, ci, value)</code> where <code>index</code> &ge; 0 specifies that element <code>index</code> should have value <code>value</code> (negative indices are permitted in this context if you like)</li>
<li>The single float item <code>value</code> which specifies an object equivalent to <code>(ri, ci+1, value)</code> (or <code>(ri+1, 0, value)</code> if <code>ci+1</code> goes past the end of the column) where <code>ri, ci</code> was the last location considered.  If this single-value form is used on the first entry, the location 0, 0 is assumed.</li>
</ul>

<p>Indices out of bounds will result in an <code>IndexError</code> and duplicate indices will result in an <code>ValueError</code>.  Order does not matter, except of course for single value entries, as their location depends on the previous entry.</p>

<p>One may set all entries of a row or column in the constraint matrix to zero by assigning <code>None</code> to or deleting the <code>matrix</code> attribute.</p>

<p>Suppose we wanted to set rather than get the earlier matrix.</p>

<pre class="c">
int    ia[] = {0+1, 0+1, 0+1,  1+1, 2+1, 1+1, 1+1, 2+1};
int    ja[] = {0+1, 1+1, 2+1,  0+1, 0+1, 1+1, 2+1, 2+1};
double ar[] = {1.0, 1.0, 1.0, 10.0, 2.0, 4.0, 5.0, 6.0}
lpx_load_matrix(lp, sizeof(ia), ia, ja, ar);
</pre>

<pre class="py">
lp.matrix = [(0, 0, 1.0), (0, 1, 1.0), (0, 2, 1.0), (1, 0, 10.0),
             (2, 0, 2.0), (1, 1, 4.0), (1, 2, 5.0), (2, 2, 6.0)]
</pre>

<p>One could also do the following.</p>

<pre class="py">
lp.matrix = [ 1.0, 1.0, 1.0,
             10.0, 4.0, 5.0,
              2.0, 0.0, 6.0 ]
</pre>

<a name="lp_nnz"><h3>Non-Zero Constraint Matrix Entries</h3></a>

<p>One gets the number of non-zero constraint matrix entries by querying the <code>nnz</code> integer attribute.</p>

<pre class="c">
int numnonzero = lpx_get_num_nz(lp);
</pre>

<pre class="py">
numnonzero = lp.nnz
</pre>

<a name="lp_basis"><h3>Basis Definition</h3></a>

<p>The user may want to define the initial LP basis prior to starting simplex optimization.  There are several automatic ways of constructing this basis.</p>

<ul>
<li><code>std_basis</code> method constructs a trivial LP basis.</li>
<li><code>adv_basis</code> method constructs an advanced LP basis that tries to have as few fixed variables as possible while maintaining the triangularity of the basis matrix.</li>
<li><code>cpx_basis</code> method constructs an advanced LP basis as described in R. Bixby. "Implementing the Simplex method: The initial basis." <i>ORSA Journal on Computing</i>, 4(3), 1992.</li>
<li><code>read_basis</code> reads a basis stored in the fixed MPS file format from a given file name.  If this method fails, it throws a <code>RuntimeError</code>.</li>
</ul>

<pre class="c">
lpx_std_basis(lp);
lpx_adv_basis(lp);
lpx_cpx_basis(lp);
lpx_read_basis(lp, "/path/to/file");
</pre>

<pre class="py">
lp.std_basis()
lp.adv_basis()
lp.cpx_basis()
lp.read_basis("/path/to/file")
</pre>

<a name="lp_scale"><h3>Scaling</h3></a>

<p>Prior to optimization, it is often help to scale your problem, in part to avoid numerical instability.  The method <code>scale</code> tells the linear program to transform the program into an alternate equivalent formulation with better numerical properties.  <strong>Note that this transformation is transparent to the user.</strong>  This is a matter of internal representation used to help the solver.</p>

<p>By passing on an optional argument that evaluates to false, one can cancel any previous scaling.</p>

<pre class="c">
lpx_scale_prob(lp);
lpx_unscale_prob(lp);
</pre>

<pre class="py">
lp.scale()
lp.scale(False)
</pre>

<a name="lp_mip"><h3>Problem Kind, Continuous or Mixed Integer</h3></a>

<p>One gets and sets the kind of problem (the default linear program or mixed integer) by querying or assigning the attribute <code>kind</code>.  This will hold either <code>float</code> if this is a pure linear program (LP), or <code>int</code> if this is a mixed integer program (MIP).</p>

<pre class="c">
lpx_set_class(lp, LPX_LP);
lpx_set_class(lp, LPX_MIP);
int thekind = lpx_get_class(lp);
</pre>

<pre class="py">
lp.kind = float
lp.kind = int
thekind = lp.kind
</pre>

<a name="lp_nintbin"><h3>Integer and Binary Columns</h3></a>

<p>One gets the number of integer and binary (i.e., integer with 0, 1 bounds) column variables by querying the <code>nint</code> and <code>nbin</code> integer attributes, respectively.  If this is not a mixed integer problem, these attributes always hold 0.</p>

<pre class="c">
int num_int = lpx_get_num_int(lp);
int num_bin = lpx_get_num_bin(lp);
</pre>

<pre class="py">
num_int = lp.nint
num_bin = lp.nbin
</pre>

<a name="lp_solvers"><h3>Solving the Problem</h3></a>

<p>When it comes time to actually solving a linear program, one calls a <code>lp.<i>solver</i>()</code> method, where <code><i>solver</i></code> refers to one of several solver methods.  There are several choices available.</p>

<ul>
<li><code>simplex</code> is a standard simplex method.</li>
<li><code>exact</code> is an <a href="http://gmplib.org/">exact</a> simplex method.<!-- , which uses the <a href="http://gmplib.org/">GNU Multiple Precision library</a> to compute exact numbers in the tableau. --></li>
<li><code>interior</code> is an interior point method.</li>
<li><code>integer</code> is a method that uses a branch-and-bound based method to solve a mixed integer program (MIP).  This method requires an existing optimal basic solution as acquired through either <code>simplex()</code> or <code>exact().</code></li>
<li><code>intopt</code> is a more advanced branch-and-bound MIP solver.  This does not require an existing optimal basic solution.</li>
</ul>

<p>Return values are either <code>None</code> if the solver terminated normally, or a string denoting one of several possible error messages.  See help for each method to review these possible return values.</p>

<pre class="c">
lpx_simplex(lp);
lpx_exact(lp);
lpx_interior(lp);
lpx_integer(lp);  <font class="comment">// These two may be applied only to MIP problems</font>
lpx_intopt(lp);
</pre>

<pre class="py">
lp.simplex()
lp.exact()
lp.interior()
lp.integer()  <font class="comment"># These two may be applied only to MIP problems</font>
lp.intopt()
</pre>

<p>Note, the solver not returning a message simply means that it terminated without error.  <strong>It does not mean that an optimal solution or indeed any solution was found!</strong>  For example, a solver could terminate without error if it determines that there is no feasible solution.</p>

<a name="lp_status"><h3>Solution Status</h3></a>

<p>One gets the solution status for the last solver by querying the <code>status</code> attribute.  This takes the form of a string with several possible values.<p>

<ul>
<li><code>opt</code> meaning the solution is optimal.</li>
<li><code>undef</code> meaning the solution is undefined.</li>
<li><code>feas</code> meaning the solution is feasible, but not necessarily optimal.</li>
<li><code>infeas</code> meaning the solution is infeasible.</li>
<li><code>nofeas</code> meaning the problem has no feasible solution.</li>
<li><code>unbnd</code> meaning the problem has an unbounded solution.</li>
</ul>

<pre class="c">
int stat = lpx_get_status(lp); <font class="comment">// or lpx_(ipt|mip)_status</font>
</pre>

<pre class="py">
stat = lp.status
</pre>

<p>Unlike the C API, PyGLPK remembers which solver was used last and retrieves the corresponding status value.  If for whatever reason you wish to retrieve the status of a solver's solution other than what was used last, you may ask for <code>status_s</code> (for <code>simplex</code> and <code>exact</code>), or <code>status_i</code> (for <code>interior</code>), or <code>status_m</code> (for <code>integer</code> or <code>intopt</code>).</p>

<p>Additionally, if one has used the simplex solver, one can get the primal and dual status with the <code>status_primal</code> and <code>status_dual</code> attributes.</p>

<pre class="c">
int pstat = lpx_get_prim_stat(lp);
int dstat = lpx_get_dual_stat(lp);
</pre>

<pre class="py">
pstat = lp.status_primal
dstat = lp.status_dual
</pre>

<a name="lp_ray"><h3>Ray</h3></a>

<p>If, after running a simplex optimizer, your basic solution is unbounded, you may retrieve the row or column corresponding to the non-basic variable causing primal unboundedness within the attribute <code>ray</code>.  The meaning of this is that corresponding variable is able to infinitely change in some unbounded direction to improve the objective function.</p>

<pre class="c">
int the_var_index = lpx_get_ray_info(lp);
</pre>

<pre class="py">
row_or_col = lp.ray
</pre>

<a name="lp_finput"><h3>File Input</h3></a>

<p>In addition to programmatically defining a linear problem, there are methods to read linear programs and MIPs from files.  We have seen the empty LPX constructor employed to create an empty problem.  The LPX constructor also has the ability to accept a single keyword argument: the keywords specifies a file format, and the argument specifies the filename, as in <code>lp=glpk.LPX(<i>format</i>=<i>filename</i>)</code>.  If successfully read, an LPX instance will be created with the file data.</p>

<p>All formats accept a single string representing the path to the file to be read.  Valid formats include the following.
<ul>
<li><code>gmp</code> for reading a model and a data file in the GNU MathProg modeling language</li>
<li><code>mps</code> for reading a fixed <a href="http://en.wikipedia.org/wiki/MPS_(format)">MPS</a> formatted files</li>
<li><code>freemps</code> for reading a free MPS formatted file</li>
<li><code>cpxlp</code> for reading a CPLEX LP formatted file</li>
<li><code>glp</code> for reading a GNU LP formatted file</li>
</ul>
</p>

<p>The format <code>gmp</code> (GNU MathProg), in addition to accepting a single string argument, may optionally accept a three element tuple instead, containing these elements:
<ul>
<li>A file name argument specifying the GMP model file.</li>
<li>A file name argument specifying the GMP data file.  This may optionally be <code>None</code> if the data is included in the model file.</li>
<li>A file name argument specifying the output file, where the output of any "display" statements in the GMP are output.  This may optionally be <code>None</code> to send output to standard output.</li>
</ul>
For the <code>gmp</code> option, if you input a single string <code>filename</code> instead of a tuple, it is equivalent to inputing the tuple <code>(filename, None, None)</code>.
</p>

<pre class="c">
lp = lpx_read_mps("/path/to/mps_file")
lp = lpx_read_freemps("/path/to/free_mps_file")
lp = lpx_read_cpxlp("/path/to/cplexlp_file")
lp = lpx_read_model("modelfile", NULL, NULL)
lp = lpx_read_model("modelfile", "datafile", "output.txt")
lp = lpx_read_prob("/path/to/gnulp_file")
</pre>

<pre class="py">
lp = glpk.LPX(mps="/path/to/mps_file")
lp = glpk.LPX(freemps="/path/to/free_mps_file")
lp = glpk.LPX(cpxlp="/path/to/cplexlp_file")
lp = glpk.LPX(gmp="modelfile")
lp = glpk.LPX(gmp=("modelfile", "datafile", "output.txt"))
lp = glpk.LPX(glp="/path/to/gnulp_file")
</pre>

<a name="lp_foutput"><h3>File Output</h3></a>

<p>One may export data about a linear program to a file in a variety of formats conveying a variety of different types of information using the method <code>write</code>.  The method accepts a large number of keyword arguments: each keyword specifies a file format, and the argument a file name, as in <code>lp.write(<i>format</i>=<i>filename</i>)</code>.  Upon invocation, the LPX object will attempt to write the data specified by the format into the indicated file.</p>

<p>Valid formats include the following.
<ul>
<li><code>mps</code> for problem data in the fixed MPS format.</li>
<li><code>bas</code> for the LP basis in fixed MPS format.</li>
<li><code>freemps</code> for problem data in the free MPS format.</li>
<li><code>cpxlp</code> for problem data in the CPLEX LP format.</li>
<li><code>glp</code> for problem data in the GNU LP format.</li>
<li><code>prob</code> for problem data in a plain text format.</li>
<li><code>sol</code> for basic solution in printable format.</li>
<li><code>sens_bnds</code> for bounds sensitivity information.</li>
<li><code>ips</code> for interior-point solution in printable format.</li>
<li><code>mip</code> for MIP solution in printable format.</li>
</ul>
Note that you can specify multiple formats and output files in a single call to <code>write</code> in order to write multiple files in multiple formats in one go.  For example, you might want to simultaneously write out printable problem data, solutions, and bounds sensitivity information all in one go with something like <code>lp.write(prob="foo.prob", sol="foo.sol", sens_bnds="foo.bnds")</code> .
</p>

<pre class="c">
lpx_write_mps(lp, filename)
lpx_write_bas(lp, filename)
lpx_write_freemps(lp, filename)
lpx_write_prob(lp, filename)
lpx_write_cpxlp(lp, filename)
lpx_print_prob(lp, filename)
lpx_print_sol(lp, filename)
lpx_print_sens_bnds(lp, filename)
lpx_print_ips(lp, filename)
lpx_print_mip(lp, filename)
</pre>

<pre class="py">
lp.write(mps=filename)
lp.write(bas=filename)
lp.write(freemps=filename)
lp.write(glp=filename)
lp.write(cpxlp=filename)
lp.write(prob=filename)
lp.write(sol=filename)
lp.write(sens_bnds=filename)
lp.write(ips=filename)
lp.write(mip=filename)
</pre>

<a name="obj"><h2>Objective Function</h2></a>

<p>A linear program objective function specifies what linear function the LP is attempting to either minimize or maximize.  Correspondingly, the objective object allows one to set objective function coefficients and the direction of optimization, and retrieve the objection function value after optimization.</p>

<p>The objective function for an LPX object <code>lp</code> is contained within <code>lp.obj</code>.  This objects is an instance of the <code>Objective</code> class.  Through this object one can set the objective coefficients and retrieve the objective value.</p>

<a name="obj_name"><h3>Naming Objective Function</h3></a>

<p>Similar to how one names problems, one gets and sets the name for the objective function by querying or assigning to the <code>name</code> attribute.  As with the C API, names are limited to 255 characters.  Unset names are <code>None</code>.  One unsets a name by assigning <code>None</code> or deleting the <code>name</code>.</p>

<pre class="c">
lpx_set_obj_name(lp, "some name");
lpx_set_obj_name(lp, NULL);
char *thename = lpx_get_obj_name(lp);
</pre>

<pre class="py">
lp.obj.name = "some name"
del lp.obj.name
thename = lp.obj.name
</pre>

<a name="obj_minmax"><h3>Minimize or Maximize</h3></a>

<p>One gets and sets whether this is a minimization or maximization problem by querying or assigning to the <code>maximize</code> boolean attribute.</p>

<pre class="c">
lpx_set_obj_dir(lp, LPX_MIN);
lpx_set_obj_dir(lp, LPX_MAX);
int ismax = (lpx_get_obj_dir(lp) == LPX_MAX);
</pre>

<pre class="py">
lp.obj.maximize = False
lp.obj.maximize = True
ismax = lp.obj.maximize
</pre>

<a name="obj_coef"><h3>Objective Coefficients</h3></a>

<p>One gets and sets the objective function coefficients by indexing into the <code>obj</code> object, e.g., <code>lp.obj[index]</code>.  There are as many objective coefficients as there are columns, so valid indices include <code>0</code> through <code>len(lp.cols)-1</code> as well as (for negative indexing) <code>-1</code> through <code>-len(lp.cols)</code>.</p>

<p>One can access and change these objective coefficients through either a single index, or access or change multiple coefficients by defining multiple indices through either a series of indices or a slice.</p>

<p>When assigning new objective coefficients, valid assignments include single numbers (in which case all indexed coefficients receive this same value) or an iterable object (in which case all indexed coefficients receive values specified in turn).</p>

<p>The objective function's constant shift term can be accessed either by using <code>None</code> as an index, or by accessing the <code>shift</code> attribute, that is, <code>lp.obj.shift</code>.</p>

<pre class="c">
lpx_set_obj_coef(lp, 2+1, 3.0);
for (i=0; i&lt;lpx_get_num_cols(lp); ++i)
	lpx_set_obj_coef(lp, i+1, 1.0)
lpx_set_obj_coef(lp, 0+1, 3.14159); lpx_set_obj_coef(lp, 2+1, -2.0);
lpx_set_obj_coef(lp, 0, 0.5);
lpx_set_obj_coef(lp, lpx_get_num_cols(lp), 25.0);
double c = lpx_get_obj_coef(lp, 3+1);
double c1 = lpx_get_obj_coef(lp, 1+1), c2 = lpx_get_obj_coef(lp, 2+1);
</pre>

<pre class="py">
lp.obj[2] = 3.0
lp.obj[:] = 1.0
lp.obj[0,2] = 3.14159, -2.0
lp.obj.shift = 0.5		<font class="comment"># Alternately, lp.obj[None] = 0.5</font>
lp.obj[-1] = 25.0
c = lp.obj[3]
c1, c2 = lp.obj[1,2]
</pre>

<a name="obj_value"><h3>Objective Function Value</h3></a>

<p>One gets the value for the objective function by querying the <code>value</code> attribute.</p>

<pre class="c">
double oval = lpx_get_obj_val(lp); <font class="comment">// or lpx_(ipt|mip)_obj_val</font>
</pre>

<pre class="py">
oval = lp.obj.value
</pre>

<p>Unlike the C API, PyGLPK remembers which solver was used last and retrieves the corresponding objective function value.  If for whatever reason you wish to retrieve an objective function from a solver type different from what you used last, you can force the issue by asking for <code>value_s</code> (for <code>simplex</code> and <code>exact</code>), or <code>value_i</code> (for <code>interior</code>), or <code>value_m</code> (for <code>integer</code> or <code>intopt</code>).</p>

<pre class="c">
double soval = lpx_get_obj_value(lp);
double ioval = lpx_ipt_obj_value(lp);
double moval = lpx_mip_obj_value(lp);
</pre>

<pre class="py">
soval = lp.obj.value_s
ioval = lp.obj.value_i
moval = lp.obj.value_m
</pre>

<a name="rc"><h2>Rows and Columns</h2></a>

<p>In a linear program, rows and columns correspond to variables.  Correspondingly, individual rows and column objects contain methods and data pertaining to individual variables: bounds, values after optimization, status, relevant entries of the constraint matrix, and other such objects.</p>

<p>Rows and columns live all live within two objects stored within an LPX object <code>lp</code> as <code>lp.rows</code> and <code>lp.cols</code>.  Both of these objects is an instance of the <code>BarCollection</code> class.  Individual rows and columns, all of type <code>Bar</code>, can be accessed by indexing or iteration over these collections.</p>

<a name="rc_add"><h3>Adding Rows and Columns</h3></a>

<p>To add rows or columns, call the <code>add</code> method on either the <code>row</code> or <code>column</code> subcontainer.  As in the C API, the newly created rows and columns are initially empty, and the return value of the <code>add</code> method holds the first newly valid index.</p>

<pre class="c">
int rnew = lpx_add_rows(lp, nrs);
int cnew = lpx_add_cols(lp, ncs);
</pre>

<pre class="py">
rnew = lp.rows.add(nrs)
cnew = lp.cols.add(ncs)
</pre>

<a name="rc_num"><h3>Number of Rows and Columns</h3></a>

<p>One gets the number of rows or columns by querying the length of the LP's <code>row</code> and <code>column</code> containers.</p>

<pre class="c">
int nrs = lpx_get_num_rows(lp);
int ncs = lpx_get_num_cols(lp);
</pre>

<pre class="py">
nrs = len(lp.rows)
ncs = len(lp.cols)
</pre>


<a name="rc_accessing"><h3>Indexing Rows and Columns</h3></a>

<p>One accesses particular rows and columns by indexing into the <code>lp.rows</code> and <code>lp.cols</code> collections.  For example, <code>lp.rows[ri]</code> returns the row at index <code>ri</code>.  This index may also be a negative index counting backwards from the end of the collection, e.g., <code>lp.cols[-1]</code> to get the last column of the LP.</p>

<p>These structures adopt much of the familiar behavior of Python sequences.  Among other implications, this means that unlike in the C API, rows and columns are indexed from 0.</p>

<p>As we shall see, rows and columns can be named.  One may also index named rows and columns by their names.</p>

<pre class="c">
int rownum = lpx_find_row(lp, "rowname")
</pre>
<pre class="py">
row = lp.rows["rowname"]
</pre>

<p>In addition to single integer or string values, one may specify multiple values in this index to retrieve a list of all specified rows or columns.</p>

<pre class="py">
lp.cols[2,5,"bob",6] <font class="comment"># columns 2, 5, one named "bob", 8</font>
</pre>

<p>Indexing by slicing is supported as well.  This will result in a list of all indices specified by the slice.</p>

<pre class="py">
lp.rows[4:9]         <font class="comment"># rows 4 through 8</font>
lp.cols[-3:]         <font class="comment"># the last 3 columns</font>
lp.rows[::2]         <font class="comment"># every row with an even index</font>
</pre>

<p>One may also iterate over the <code>lp.rows</code> and <code>lp.cols</code> collections. Here is a comparative example of setting each column to name <code>x</code><var>i</var>, where <var>i</var> is the index of this column, so the columns will be named <code>x0</code>, <code>x1</code>, <code>x2</code>, etc.</p>

<pre class="c">
char buff[10];
for (i=1; i<=lpx_get_num_cols(lp); ++i) {
	snprintf(buff, sizeof(buff), "x%d", i-1);
	lpx_set_col_name(lp, i, buff);
}
</pre>

<pre class="py">
for col in lp.cols:
	col.name = "x%d" % col.index
</pre>

<a name="rc_name"><h3>Naming Rows and Columns</h3></a>

<p>As with the problem and the objective function, one gets and sets the name for a row or column by querying or assigning the attribute <code>name</code>.</p>

<p>Note the use of an index into the <code>rows</code> or <code>cols</code> collections to retrieve a particular row or columns.  As with the C API, indices are integral, though we count from 0.</p>

<pre class="c">
lpx_set_row_name(lp, ri+1, "row name");
lpx_set_col_name(lp, ci+1, "col name");
char *rname = lpx_get_row_name(lp, ri+1);
char *cname = lpx_get_col_name(lp, ci+1);
</pre>

<pre class="py">
lp.rows[ri].name = "row name"
lp.cols[ci].name = "col name"
rname = lp.rows[ri].name
cname = lp.cols[ci].name
</pre>

<p>After the user names a row or column, they may index this row or column by its name.</p>

<pre class="py">
lp.rows[ri].name = "xi"
therow = lp.rows["xi"]
</pre>

<a name="rc_bounds"><h3>Bounding Rows and Columns</h3></a>

<p>One gets and sets the bounds for a row or column by querying or assigning the attribute <code>bounds</code>.  To set bounds, one may assign one or two values to the <code>bounds</code>, where values are either <code>None</code> or numeric.</p>

<p>One <code>None</code> (or two <code>None</code>s) sets the row's auxiliary (or column's structural) variable unbounded.  (One may also delete the bounds.)  One numeric value (or two equal numeric values) sets an equality bound.  In the case of two values, the first is interpreted as a lower bound, the second as an upper bound, with <code>None</code> indicating unboundedness in that direction.  Setting a lower bound greater than an upper bound causes a <code>ValueError</code>.</p>

<p>In this code, we see instances of setting free (unbounded), lower, upper, double, and fixed (equality) bounds, respectively on a row and column.</p>

<pre class="c">
lpx_set_row_bnds(lp, ri+1, LPX_FR,  0,   0);
lpx_set_row_bnds(lp, ri+1, LPX_LO,  2,   0);
lpx_set_col_bnds(lp, ci+1, LPX_UP,  0,   5);
lpx_set_col_bnds(lp, ci+1, LPX_DB, -1,   3.14159);
lpx_set_row_bnds(lp, ri+1, LPX_FX,  3.4, 3.4);
</pre>

<pre class="py">
lp.rows[ri].bounds = None        <font class="comment"># Or, lp.rows[ri].bounds = None, None</font>
                                 <font class="comment"># Or, del lp.rows[ri].bounds</font>
lp.rows[ri].bounds = 2, None
lp.cols[ci].bounds = None, 5
lp.cols[ci].bounds = -1, 3.14159
lp.rows[ri].bounds = 3.4         <font class="comment"># Or, lp.rows[ri].bounds = 3.4, 3.4</font>
</pre>

<p>Accessing bounds always yields two values (again, either <code>None</code> or numeric) representing lower and upper bounds respectively, even if the bounds resulted from either a single value assignment or a deletion.  Again, <code>None</code> represents unboundedness in that direction.</p>

<a name="rc_matrix"><h3>Matrix Entries of Rows and Columns</h3></a>

<p>One gets and sets the entries of a row or column in the constraint matrix by querying or assigning the attribute <code>matrix</code>.  Assignments to <code>matrix</code> will remove previous entries.</p>

<p>Retrieving <code>matrix</code> will yeild a list of two element tuples over the non-zero entries in this row or column, each of the form <code>(index, value)</code>.  The <code>index</code> is the index (counting from 0) of the entry holding value <code>value</code> in this row or column.</p>

<p>If we have an LPX object with <var>r</var> rows and <var>c</var> columns, then valid indices for rows are 0 through <var>c</var>&minus;1, and valid entries for columns are 0 through <var>r</var>&minus;1.</p>

<p>For example, suppose for an object <code>lp</code> the row <var>r</var><sub>2</sub> (that is, row at index 2) encodes the constraint:</p>

<p align="center"><var>p</var> = 10<var>x</var><sub>0</sub> &minus; 3.14159<var>x</var><sub>1</sub> + 0.5<var>x</var><sub>3</sub>
</p>

<p>Then <code class="py">print lp.rows[2].matrix</code> outputs <code class="out">[(0, 10.0), (1, -3.14159), (3, 0.5)]</code>.</p>

<p>One may set all non-zero entries of a row or column by assigning an iterable with similar structure to the <code>matrix</code> attribute.  Suppose our LPX object has <var>numr</var> rows and <var>numc</var> columns.  The iterable must yield values each in one of these two forms:</p>
<ul>
<li>The integer-float tuple <code>(index, value)</code> which specifies that element <code>index</code> should have value <code>value</code> (note that negative indices are permitted in this context if you like)</li>
<li>The single float item <code>value</code> which specifies an object equivalent to <code>(index+1, value)</code> where <code>index</code> was the last index used in this iterable, or 0 if this is the first object in the iterable</li>
</ul>

<p>For example, where one interested in defining (rather than simply retrieving) the entries of the constraint row used in the example above, if there are four columns, all of the following are equivalent:</p>
<pre class="py">
<font class="comment"># Define constraint p = 10*x0 - 3.14159*x1 + 0.5*x3</font>
lp.rows[2].matrix = [(0, 10), (1, -3.14159), (3, 0.5)]
lp.rows[2].matrix = [(0, 10), (1, -3.14159), (-1, 0.5)]
lp.rows[2].matrix = [(1, -3.14159), (0, 10), (3, 0.5)]
lp.rows[2].matrix = [10, -3.14159, 0, 0.5]
lp.rows[2].matrix = [10, -3.14159, (-1, 0.5)]
lp.rows[2].matrix = [10, -3.14159, (3, 0.5)]
</pre>

<p>Indices out of bounds will result in an <code>IndexError</code> and duplicate indices will result in an <code>ValueError</code>.  Order does not matter, except of course for single value entries, as their index depends on the previous entry.</p>

<p>One may set all entries of a row or column in the constraint matrix to zero by assigning <code>None</code> to or deleting the <code>matrix</code> attribute.</p>

<a name="rc_nnz"><h3>Number of Non-Zero Constraint Row and Column Entries</h3></a>

<p>One gets the number of non-zero constraint elements within a row or a column by querying the <code>nnz</code> integer attribute.</p>

<pre class="c">
int rnnz = lpx_get_mat_row(lp, ri+1, NULL, NULL);
int cnnz = lpx_get_mat_col(lp, ci+1, NULL, NULL);
</pre>

<pre class="py">
rnnz = lp.row[ri].nnz
cnnz = lp.col[ci].nnz
</pre>

<a name="rc_delete"><h3>Deleting Rows and Columns</h3></a>

<p>To delete rows or columns, delete as one would from a typical Python list.  Note the methods of indexing into the row and column collections.  Accepted indices include single values, lists of values, or slices.</p>

<pre class="c">
int indices1[] = { 2+1 };
lpx_del_cols(lp, 1, indices1-1);
int indices2[] = { 2+1,5+1,6+1 };
lpx_del_rows(lp, 3, indices2-1);
int indices3[] = { 3+1, 4+1, 5+1, 6+1 };
lpx_del_cols(lp, 4, indices3-1);
</pre>

<pre class="py">
del lp.cols[2]       <font class="comment"># Remove col indexed at 2</font>
del lp.rows[2,5,6]   <font class="comment"># Remove rows indexed at 2,5,6</font>
del lp.cols[3:7]     <font class="comment"># Remove cols indexed at 3,4,5,6</font>
</pre>

<a name="rc_special"><h3>Special Attributes of Rows and Columns</h3></a>

<p>As is clear from the previous examples, row and column collections (e.g., as accessed by <code>lp.rows</code>) and rows and columns (e.g., as accessed by <code>lp.rows[i]</code>) as well as the rows and columns themselves are bona fide objects.  (This was a design choice: rather than having only the LPX class where one defines a hundred or so get and set methods, as the C API must, one retrieves the rows and columns and operates on them instead.)</p>

<p>As a point of implementation, these row and column objects do not contain the row and column data.  In reality, they just contain a pointer back to the LPX and an index.  We shall see consequences of this in this subsection.</p>

<p>Aside from attributes which have obvious analogies to functions in the C API (e.g., <code>name</code> with the <code>lpx_[gs]et_(row|col)_name</code> functions), rows and columns have other special attributes that do not have analogies in the C API which are exposed to Python users in the hope they may find them useful.</p>

<p><code>index</code> is an integer attribute containing the index of this row or column.</p>

<p><code>valid</code> is a boolean attribute containing whether this row or column is valid.  A row or column may become invalid if its index points to somewhere beyond the current size of the LPX.  This is mostly useless: one can track the size of the program, and even if you do not, using an out of date row or column safely throws exceptions.</p>

<p><code>isrow</code> and <code>iscol</code> are boolean attributes indicating whether this is a row or a column.  Naturally these two attributes are inverses of each other.</p>

<p>Example usage of these principles to elucidate these implementations is illustrated in this example.  All assertions in this snippet are satisfied.</p>

<pre class="py">
lp = glpk.LPX()
lp.rows.add(3)
lp.rows[0].name, lp.rows[1].name, lp.rows[2].name = 'p', 'q', 'r'
row1, row2 = lp.rows[1], lp.rows[2]
assert row1.name == 'q' and row2.name == 'r'
del lp.rows[1]
assert row1.name == 'r' and row1.valid and not row2.valid
assert row1.isrow
</pre>

<a name="rc_basis"><h3>Row and Column Basis Status</h3></a>

<p>One gets and sets the current basis status for a row or column by querying or assigning the attribute <code>status</code>.  This is a two-character string with the following possible values.<p>

<ul>
<li><code>bs</code> meaning this row/column is basic.</li>
<li><code>nl</code> meaning this row/column is non-basic.</li>
<li><code>nu</code> meaning this row/column is non-basic and set to the upper bound.  On assignment, if this row/column is not double bounded, this is equivalent to <code>nl</code>.</li>
<li><code>nf</code> meaning this row/column is non-basic and free.  On assignment this is equivalent to <code>nl</code>.</li>
<li><code>ns</code> meaning this row/column is non-basic and fixed.  On assignment this is equivalent to <code>nl</code>.</li>
</ul>

<pre class="c">
if (lpx_get_row_stat(lp, ri+1) == LPX_BS)
	printf("row is basic\n");
else
	printf("row is non-basic\n");
</pre>

<pre class="py">
if lp.rows[ri].status == "bs":
	print "row is basic"
else:
	print "row is non-basic"
</pre>

<p>As an example of setting the status, the user may wish to assign to this attribute in order to manually define the initial basis and not rely upon the automatic basis definition methods <code>lp.*_basis()</code>.  To illustrate this, here is the code within the GLPK standard basis code in both C and Python versions.</p>

<pre class="c">
int i, j, m, n, type;
double lb, ub;
<font class="comment">// all auxiliary variables are basic</font>
m = lpx_get_num_rows(lp);
for (i = 1; i <= m; i++)
	lpx_set_row_stat(lp, i, LPX_BS);
<font class="comment">// all structural variables are non-basic</font>
n = lpx_get_num_cols(lp);
for (j = 1; j <= n; j++) {
	type = lpx_get_col_type(lp, j);
	lb = lpx_get_col_lb(lp, j);
	ub = lpx_get_col_ub(lp, j);
	if (type != LPX_DB || fabs(lb) <= fabs(ub))
		lpx_set_col_stat(lp, j, LPX_NL);
	else
		lpx_set_col_stat(lp, j, LPX_NU);
}
</pre>

<pre class="py">
<font class="comment"># all auxiliary variables are basic</font>
for row in lp.rows:
	row.status = "bs"
<font class="comment"># all structural variables are non-basic</font>
for col in lp.cols:
	lb, ub = col.bounds
	if lb==None or ub==None or abs(lb)<=abs(ub):
		col.status = "nl"
	else:
		col.status = "nu"
</pre>

<a name="rc_mip"><h3>Column Variable Kind, Continuous or Integer</h3></a>

<p>One gets and sets the kind of variable (the default continuous, or integer) by querying or assigning the attribute <code>kind</code>.  This will hold either <code>float</code> if this is a continuous variable, or <code>int</code> if this is an integer variable.</p>

<pre class="c">
lpx_set_col_kind(lp, ci+1, LPX_CV);
lpx_set_col_kind(lp, ci+1, LPX_IV);
int kind = lpx_get_col_kind(lp, ci+1);
</pre>

<pre class="py">
lp.cols[ci].kind = float
lp.cols[ci].kind = int
kind = lp.cols[ci].kind
</pre>

<p>Note that setting a column variable as integer requires that the <code>lp</code> be a MIP problem, i.e., <code>lp.kind==int</code>.  In the event that <code>lp.kind==float</code>, all variable assignments to kind <code>int</code> will fail, and all variables will return <code>float</code> when asked their kind.</p>

<p>Another note, rows must be continuous.  As a matter of implementation, because they are the same type of object as columns, they may also be queried and assigned to in this fashion.  However, their <code>kind</code> attribute always returns and only accepts <code>float</code>.</p>

<a name="rc_value"><h3>Row and Column Variable Values</h3></a>

<p>One gets a row or column's variable value by querying the <code>primal</code>, <code>dual</code>, or <code>value</code> attribute.</p>

<pre class="c">
double pval = lpx_get_row_prim(ri+1); <font class="comment">// if simplex</font>
double dval = lpx_get_col_dual(ci+1);
</pre>

<pre class="py">
pval = lp.rows[ri].primal
dval = lp.cols[ci].dual
</pre>

<p>The two attributes <code>primal</code> and <code>value</code> are interchangable.  The term value is used to refer to the solutions of the MIP since it only has one type of value (no dual).  However, since it is the same type of value (loosely speaking), this "link" between the two was established.</p>

<p>Note that unlike the C API, this remembers which solver was used last and retrieves the appropriate corresponding variable value.  If for whatever reason you wish to retrieve a variable function from a solver type different from what you used last (e.g., reviewing the relaxed basic solution after calling <code>integer()</code>), you can ask for <code>primal_s</code> or <code>dual_s</code> (for primals and duals from <code>simplex</code> and <code>exact</code>), or <code>primal_i</code> or <code>dual_i</code> (for primals and duals from <code>interior</code>), or <code>value_m</code> (for values from <code>integer</code> or <code>intopt</code>).</p>

<pre class="c">
double prim_sim_row = lpx_get_row_prim(lp, ri+1);
double prim_sim_col = lpx_get_col_prim(lp, ci+1);
double dual_sim_row = lpx_get_row_dual(lp, ri+1);
double dual_sim_col = lpx_get_col_dual(lp, ci+1);
double prim_ipt_row = lpx_ipt_row_prim(lp, ri+1);
double prim_ipt_col = lpx_ipt_col_prim(lp, ci+1);
double dual_ipt_row = lpx_ipt_row_dual(lp, ri+1);
double dual_ipt_col = lpx_ipt_col_dual(lp, ci+1);
double valu_mip_row = lpx_mip_row_val (lp, ri+1);
double valu_mip_col = lpx_mip_col_val (lp, ci+1);
</pre>

<pre class="py">
prim_sim_row, prim_sim_col = lp.rows[ri].primal_s, lp.cols[ci].primal_s
dual_sim_row, dual_sim_col = lp.rows[ri].dual_s,   lp.cols[ci].dual_s
prim_ipt_row, prim_ipt_col = lp.rows[ri].primal_i, lp.cols[ci].primal_i
dual_ipt_row, dual_ipt_col = lp.rows[ri].dual_i,   lp.cols[ci].dual_i
valu_mip_row, valu_mip_col = lp.rows[ri].value_m,  lp.cols[ci].value_m
</pre>

<a name="params"><h2>Parameter Collection</h2></a>

<p>Contained with a linear program object <code>lp</code> is a parameter object <code>param</code>.  This helps control the behavior of the GLPK.</p>

<a name="params_value"><h3>Parameter Values</h3></a>

<p>One gets and sets parameter values by querying or assigning to one of the many attributes of the <code>lp.param</code> object, i.e., <code>lp.param.<i>param_name</i></code>.</p>

<p>For a descriptive enumeration of these parameters, either query the inline help for the Python object (i.e., <code>help(lp.params)</code>), or refer to the original GLPK C API reference manual.  Each available C parameter identifier of the form <code>LPX_K_<i>PARAMNAME</i></code> corresponds to an attribute of the <code>lp.param.<i>paramname</i></code>.  (That is, the last component downcased.)</p>

<pre class="c">
lpx_set_int_parm(lp, LPX_K_ITLIM, 250);
double relax = lpx_get_real_parm(lp, LPX_K_RELAX);
</pre>

<pre class="py">
lp.params.itlim = 250
relax = lp.params.relax
</pre>

<a name="params_reset"><h3>Resetting</h3></a>

<p>One can reset the parameter values back to their default values by calling the <code>reset</code> method.</p>

<pre class="c">
lpx_reset_parms(lp);
</pre>

<pre class="py">
lp.params.reset()
</pre>

<a name="kkt"><h2>Karush-Kuhn-Tucker Conditions</h2></a>

<p>The linear program object has the ability to return a <code>KKT</code> type objects with which the user may evaluate the fitness of either simplex or MIP solutions.</p>

<a name="kkt_get"><h3>Retrieving KKT Objects</h3></a>

<p>One can compute and retrieve these conditions for simplex solvers with the <code>kkt</code> and for integer solvers with the <code>kktint</code> methods.  The <code>kkt</code> method has an optional argument that allows one to specify whether one wants to compute the conditions for the internally scaled version of the problem (by default false).</p>

<pre class="c">
LPXKKT kkt, skkt, ikkt;
lpx_check_kkt(lp, 0,  &kkt);  <font class="comment">// unscaled simplex KKT</font>
lpx_check_kkt(lp, 1, &skkt);  <font class="comment">// scaled simplex KKT</font>
lpx_check_int(lp,    &ikkt);  <font class="comment">// integer conditions</font>
</pre>

<pre class="py">
kkt  = lp.kkt()     <font class="comment"># unscaled simplex KKT</font>
skkt = lp.kkt(True) <font class="comment"># scaled simplex KKT</font>
ikkt = lp.kktint()  <font class="comment"># integer conditions</font>
</pre>

<p>These objects have KKT statistics about the absolute and relative errors and worst rows and columns in the primal and (in the case of non-integer problems) dual solutions.  See the inline help for more information about these fields.</p>

<a name="miscnotes"><h2>Miscellaneous Notes</h2></a>

<a name="miscnotes_help"><h3>Help</h3></a>

<p>In addition to this documentation, like most Python objects, the objects have built in inline help, accessible from an interactive Python session.  For example, to access the built in documentation for the <code>glpk</code> module:</p>
<pre class="py">
help(glpk)
</pre>

<a name="miscnotes_version"><h3>Version</h3></a>

<p>The module defines a tuple that reflects the version of GLPK that the build process believed it was linking against.  For example, if the module believed it was linking against GLPK 4.15, the tuple would be <code>(4, 15)</code> .</p>

<pre class="py">
glpk.version
</pre>

<hr/>
Thomas Finley, 2007
</body>
</html>
